{"ast":null,"code":"import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport { fetchCount } from \"./FunctionComponentAPI\";\n/**\n createSlice\n\n    initial state\n    { reducer functions }\n    slice name\n\n    generates action creators and types\n     corresponding to reducers and state\n */\n\n/**\n createAsyncThunk\n\n\n    Redux action\n    callback that returns a promise\n\n    handles async request lifecycles\n    returns thunk action creator that dispatches lifecycle actions based on returned promise\n\n    write your own reducer functions for tracking loading states/ processing returned data\n */\n\nconst initialState = {\n  value: 0,\n  status: \"idle\"\n}; //dispatch action => perform async request\n\nexport const incrementAsync = createAsyncThunk(\"fCount/fetchCount\", async amount => {\n  const response = await fetchCount(amount);\n  return response.data;\n}); //reducer logic and actions for counter\n\nexport const fCSlice = createSlice({\n  name: \"fCount\",\n  initialState,\n  //define reducers and actions\n  reducers: {\n    //Immer handles \"mutating\" logic in reducers\n    increment: state => {\n      state.value += 1;\n    },\n    //decrement count\n    decrement: state => {\n      state.value -= 1;\n    },\n    //handles incrementIfEven declared later - action.payload returns the processed state\n    incrementByAmount: (state, action) => {\n      state.value += action.payload;\n    }\n  },\n  // extraReducers lets the slice handle outside actions (generated by createAsyncThunk or other slices)\n  extraReducers: builder => {\n    builder.addCase(incrementAsync.pending, state => {\n      state.status = \"loading\";\n    }).addCase(incrementAsync.fulfilled, (state, action) => {\n      state.status = \"idle\";\n      state.value += action.payload;\n    });\n  }\n}); //\n\nexport const {\n  increment,\n  decrement,\n  incrementByAmount\n} = fCSlice.actions; //select value from state\n\nexport const selectCount = state => state.fCount.value; //thunk conditionally dispatching actions based on current state\n\nexport const incrementIfEven = x => (dispatch, getState) => {\n  const currentValue = selectCount(getState());\n\n  if (currentValue % 2 === 0) {\n    dispatch(incrementByAmount(x));\n  }\n}; //\n\nexport default fCSlice.reducer;","map":{"version":3,"sources":["/Users/jrdorn/Documents/Bitsox/client/src/routes/Common/routes/HelpCenter/routes/FAQs/components/FunctionComponent/FunctionComponentSlice.js"],"names":["createAsyncThunk","createSlice","fetchCount","initialState","value","status","incrementAsync","amount","response","data","fCSlice","name","reducers","increment","state","decrement","incrementByAmount","action","payload","extraReducers","builder","addCase","pending","fulfilled","actions","selectCount","fCount","incrementIfEven","x","dispatch","getState","currentValue","reducer"],"mappings":"AAAA,SAASA,gBAAT,EAA2BC,WAA3B,QAA8C,kBAA9C;AACA,SAASC,UAAT,QAA2B,wBAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAG;AACnBC,EAAAA,KAAK,EAAE,CADY;AAEnBC,EAAAA,MAAM,EAAE;AAFW,CAArB,C,CAKA;;AACA,OAAO,MAAMC,cAAc,GAAGN,gBAAgB,CAC5C,mBAD4C,EAE5C,MAAOO,MAAP,IAAkB;AAChB,QAAMC,QAAQ,GAAG,MAAMN,UAAU,CAACK,MAAD,CAAjC;AACA,SAAOC,QAAQ,CAACC,IAAhB;AACD,CAL2C,CAAvC,C,CAQP;;AACA,OAAO,MAAMC,OAAO,GAAGT,WAAW,CAAC;AACjCU,EAAAA,IAAI,EAAE,QAD2B;AAEjCR,EAAAA,YAFiC;AAGjC;AACAS,EAAAA,QAAQ,EAAE;AACR;AACAC,IAAAA,SAAS,EAAGC,KAAD,IAAW;AACpBA,MAAAA,KAAK,CAACV,KAAN,IAAe,CAAf;AACD,KAJO;AAKR;AACAW,IAAAA,SAAS,EAAGD,KAAD,IAAW;AACpBA,MAAAA,KAAK,CAACV,KAAN,IAAe,CAAf;AACD,KARO;AASR;AACAY,IAAAA,iBAAiB,EAAE,CAACF,KAAD,EAAQG,MAAR,KAAmB;AACpCH,MAAAA,KAAK,CAACV,KAAN,IAAea,MAAM,CAACC,OAAtB;AACD;AAZO,GAJuB;AAkBjC;AACAC,EAAAA,aAAa,EAAGC,OAAD,IAAa;AAC1BA,IAAAA,OAAO,CACJC,OADH,CACWf,cAAc,CAACgB,OAD1B,EACoCR,KAAD,IAAW;AAC1CA,MAAAA,KAAK,CAACT,MAAN,GAAe,SAAf;AACD,KAHH,EAIGgB,OAJH,CAIWf,cAAc,CAACiB,SAJ1B,EAIqC,CAACT,KAAD,EAAQG,MAAR,KAAmB;AACpDH,MAAAA,KAAK,CAACT,MAAN,GAAe,MAAf;AACAS,MAAAA,KAAK,CAACV,KAAN,IAAea,MAAM,CAACC,OAAtB;AACD,KAPH;AAQD;AA5BgC,CAAD,CAA3B,C,CA+BP;;AACA,OAAO,MAAM;AAAEL,EAAAA,SAAF;AAAaE,EAAAA,SAAb;AAAwBC,EAAAA;AAAxB,IAA8CN,OAAO,CAACc,OAA5D,C,CAEP;;AACA,OAAO,MAAMC,WAAW,GAAIX,KAAD,IAAWA,KAAK,CAACY,MAAN,CAAatB,KAA5C,C,CAEP;;AACA,OAAO,MAAMuB,eAAe,GAAIC,CAAD,IAAO,CAACC,QAAD,EAAWC,QAAX,KAAwB;AAC5D,QAAMC,YAAY,GAAGN,WAAW,CAACK,QAAQ,EAAT,CAAhC;;AACA,MAAIC,YAAY,GAAG,CAAf,KAAqB,CAAzB,EAA4B;AAC1BF,IAAAA,QAAQ,CAACb,iBAAiB,CAACY,CAAD,CAAlB,CAAR;AACD;AACF,CALM,C,CAOP;;AACA,eAAelB,OAAO,CAACsB,OAAvB","sourcesContent":["import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport { fetchCount } from \"./FunctionComponentAPI\";\n\n/**\n createSlice\n\n    initial state\n    { reducer functions }\n    slice name\n\n    generates action creators and types\n     corresponding to reducers and state\n */\n\n/**\n createAsyncThunk\n\n\n    Redux action\n    callback that returns a promise\n\n    handles async request lifecycles\n    returns thunk action creator that dispatches lifecycle actions based on returned promise\n\n    write your own reducer functions for tracking loading states/ processing returned data\n */\n\nconst initialState = {\n  value: 0,\n  status: \"idle\",\n};\n\n//dispatch action => perform async request\nexport const incrementAsync = createAsyncThunk(\n  \"fCount/fetchCount\",\n  async (amount) => {\n    const response = await fetchCount(amount);\n    return response.data;\n  }\n);\n\n//reducer logic and actions for counter\nexport const fCSlice = createSlice({\n  name: \"fCount\",\n  initialState,\n  //define reducers and actions\n  reducers: {\n    //Immer handles \"mutating\" logic in reducers\n    increment: (state) => {\n      state.value += 1;\n    },\n    //decrement count\n    decrement: (state) => {\n      state.value -= 1;\n    },\n    //handles incrementIfEven declared later - action.payload returns the processed state\n    incrementByAmount: (state, action) => {\n      state.value += action.payload;\n    },\n  },\n  // extraReducers lets the slice handle outside actions (generated by createAsyncThunk or other slices)\n  extraReducers: (builder) => {\n    builder\n      .addCase(incrementAsync.pending, (state) => {\n        state.status = \"loading\";\n      })\n      .addCase(incrementAsync.fulfilled, (state, action) => {\n        state.status = \"idle\";\n        state.value += action.payload;\n      });\n  },\n});\n\n//\nexport const { increment, decrement, incrementByAmount } = fCSlice.actions;\n\n//select value from state\nexport const selectCount = (state) => state.fCount.value;\n\n//thunk conditionally dispatching actions based on current state\nexport const incrementIfEven = (x) => (dispatch, getState) => {\n  const currentValue = selectCount(getState());\n  if (currentValue % 2 === 0) {\n    dispatch(incrementByAmount(x));\n  }\n};\n\n//\nexport default fCSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}