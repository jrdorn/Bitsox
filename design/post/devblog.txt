|| Inspiration

    Reddit
    Stackoverflow
    Amazon
    MagicEden 
    Coinbase 
    Uniswap


|| Why chosen technologies

(MERN)

React
    server-side rendering
React-router
    URL routing
Redux
    maintain state
    CRUD operations
Node Express
    manage user sessions
MongoDB

Webpack

HTML

CSS


deploy to AWS | Heroku








||Structure

!fully featured ecommerce

Node
    Config

    Controllers

    Models
    mongoose config and data model 

    Routes

    server
        CORS 
        REST API
            GET/POST/PUT/DELETE HTTP methods

React-Redux
    
    Components

    .env




|| Situation, action, response





|| Challenges









||| Lessons while building


relief after modularizing break-it with vanilla JS  
    ease of React, Redux fundamentals guide then coming across Toolkit and createAsyncThunk


choosing react => redux => react-router => react-router-redux


slug- unique identifying part of a web address
    -human-readable identifier   (example.com/slug  vs  example/com/32489ufeijos)

default vs named exports 

finding elems online and using devtools to borrow styles


Structuring:  

    React container 
        "how things work" - data fetching, state updates
        components without UI 
        receive Redux state updates and dispatch actions
        usually don't render DOM elements
        delegate rendering to presentational child components 

    React components
        "how things look" - markup, styles 
        presentational, UI 

    Hooks 
        can build without arbitrary divisions

    Redux feature
        separate by each website feature or domain 


     #Common 
        =>UI 
            =>styles 
            =>scripts
        =>state
            =>local 
            =>global 

     #Pages
        =>UI
            =>styles
            =>scripts
        =>state 
            =>local
            =>global

     #Server



|| Unexpected events while building





|| General notes

React   
    sync state and ui 
    immutable state
    components
    controlled components
    virtual dom
    hooks instead of classes bit.ly/3FrDUhs
    useState, setState, useEffect, useReducer


Redux 
    central store holding entire app state
        each component can access any state from the store
        manage states shared across components 
        don't need to send props across components
        consistency across client, server, native env
    actions
        events that send data from app to store
        user events, api calls, form submissions
        store.dispatch()
        type and payload
    store
        only one per Redux app
        access
        update
        register/unregister listeners
    reducers
        current state => action => return new state object
        based on reduce(), single value calculated from many values after callback
    middleware
        e.g. sanitize login form input before sending to store
    slice 
        a "slice" of Redux state 
        reducer logic and actions for a single feature

    standard patterns
        action creators 
        memoized selectors
        tracking request status via loading enums 
        normalizing state for managing item collections
        promises and thunks

...

React  
    reconciliation algorithm
        id minimal diff between trees to update the true dom
        minimize reflow and repaint
        O(n) compute tree diff 
            2 elements of diff types always produce 2 diff dom trees 
            signal stability of child components across render cycle by prodiving key props 
    virtual tree dom    
    200k in one sec 
    breadth first search

    renders all child components recursively by default, make sure not to re-render many components when nothing has changed
        wrap componets in React.memo(), so they only re-render when their props change

Redux   
    React state won't need to be lifted up 
    debugging, see what events cause a specific outcome  
    reducers are pure functions 
    immutable state => easier undo and redo
    predictable and maintanable 

    accidentally mutating state in reducers is most common Redux error
    action creators, createSlice and createAction can accept "prepare callback" that returns action payload

    call useSelector multiple times in one component, each call should return smallest ammount of state possible
    returning new array references in selectors causes components to re-render every time

    

React-Redux 
      shallowEqual checks if items inside array are still the same
      useSelector hook lets React components read data from Redux store
      useDispatch hook lets React components dispatch actions to Redux store

    action creator pattern-writing a function to prepare something that will get passed to dispatch

    Reselect library's createSelector API generates memoized selector functions
        only useful when you derive additional values from your original data

    store data in normalized state structure 

    useStore hook


Redux Toolkit
    createSlice
    createReducer
    createAsyncThunk    
    createEntityAdapter


Pure functions  
    no side effects
    if f() depends on vars outside itself, you don't know what will happen when you run it 
    if f() mods other vals, including args, it can unexpectedly change the way the app works

arrow functions and implicit return 

Memoized selectors, Reselect library, createSelector()

JS
    .map returns array, .reduce returns single output




entities: unique items with an ID 
enums - enumeration - named constants

handle API failures and other potential errors 

working with objects 
    ... spread operators, map(), keys() 
    destructuring - export const {todoAdded, todoToggled } = todosSlice.actions 

array.filter() element removal 


optimize readability - 18px W3C/WAI standard
    objectively improved readability https://pielot.org/pubs/Rello2016-Fontsize.pdf
    1.5 - 2 line height https://www.w3.org/TR/WCAG20-TECHS/C21.html

aria-label for interactive elements

HTML name attribute identifies the input value if the value is sent to a server via GET/POST
